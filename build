#!/usr/bin/env python2.7

import os
import os.path
import re

from fabricate import *

def makedirs(d):
    if not os.path.isdir(d):
        os.makedirs(d)

def read_operations():
    with open("fetched/supercop-20130419/OPERATIONS") as f:
        for l in f:
            op, macros, prototypes = l.strip().split(None, 2)
            macros = macros.split(':')
            prototypes = prototypes.split(':')
            yield (op, dict(macros=macros, prototypes=prototypes))

operations = dict(read_operations())

o_header = """#ifndef {o}_H
#define {o}_H

#include "{op}.h"

{op_macros}

{o_macros}
#define {o}_PRIMITIVE "{p}"
#define {o}_IMPLEMENTATION {op}_IMPLEMENTATION

#endif
"""

op_header = """#ifndef {op}_H
#define {op}_H

{apisubst}
#ifdef __cplusplus
extern "C" {{
#endif
{prototypes}
#ifdef __cplusplus
}}
#endif

#define {op}_IMPLEMENTATION "{o}/{p}/{i}"
#ifndef {op}_VERSION
#define {op}_VERSION "-"
#endif

#endif
"""

cffi_op_header = """
{cffi_declarations}
extern char *cffi_{op}_IMPLEMENTATION;
extern char *cffi_{op}_VERSION;

{prototypes}
"""

cffi_constants = """
#include "{op}.h"
#include "cffi_{op}.h"

{cffi_definitions}
char *cffi_{op}_IMPLEMENTATION = {op}_IMPLEMENTATION;
char *cffi_{op}_VERSION = {op}_VERSION;
"""

class Primitive(object):
    def spath(self):
        return os.path.join(
            self._ptype,
            self._cipher,
            self._implementation)

    def target_dir(self, *args):
        return os.path.join("target", self.spath(), *args)

    def source_dir(self, *args):
        return os.path.join("fetched/supercop-20130419", self.spath(), *args)

    def ops(self, entry):
        return operations[self._ptype][entry]

    def api(self):
        with open(self.source_dir("api.h")) as f:
            return f.read()

    def add_macro(self, substitutions, name, macros, template):
        substitutions[name] = "\n".join(
            template.format(**dict(substitutions, macro=macro))
            for macro in macros)

    def write_template(self, d, namepattern, template, substitutions):
        makedirs(self.target_dir(d))
        name = self.target_dir(d,
            namepattern.format(**substitutions))
        print "Writing", name
        with open(name, "w") as f:
            f.write(template.format(**substitutions))

    def write_templates(self):
        substitutions = dict(
            o=self._ptype,
            p=self._cipher,
            i=self._implementation)
        substitutions["op"] = "{o}_{p}".format(**substitutions)
        substitutions["opi"] = "{op}_{i}".format(**substitutions)
        macros = self.ops("macros") + ["_VERSION"]
        self.add_macro(substitutions, "o_macros", macros,
            "#define {o}{macro} {op}{macro}")
        self.add_macro(substitutions, "op_macros", macros,
            "#define {opi}{macro} {op}{macro}")
        macros = [x for x in self.ops("macros") if x.endswith("BYTES")]
        self.add_macro(substitutions, "cffi_declarations", macros,
            "extern int cffi_{op}{macro};")
        self.add_macro(substitutions, "cffi_definitions", macros,
            "int cffi_{op}{macro} = {op}{macro};")
        substitutions["apisubst"] = re.sub(
            r"\sCRYPTO_",
            " {op}_".format(**substitutions),
            self.api().strip())
        substitutions["prototypes"] = "\n".join(
            "extern int {op}{prototype};".format(
                **dict(substitutions, prototype=prototype))
            for prototype in self.ops("prototypes"))
        self.write_template("include",
            "{o}.h", o_header, substitutions)
        self.write_template("include",
            "{op}.h", op_header, substitutions)
        self.write_template("include",
            "cffi_{op}.h", cffi_op_header, substitutions)
        self.write_template("c",
            "cffi_constants.c", cffi_constants, substitutions)

    def compile_c(self, name, source):
        run("cc", "-fpic", "-Wall",
            "-I", self.target_dir("include"),
            "-c",
            "-o",  self.target_dir("obj", name + ".o"), source)

    def build(self):
        self.write_templates()
        obj = self.target_dir("obj")
        makedirs(obj)
        for name in self._cfiles:
            self.compile_c(name, self.source_dir(name + ".c"))
        self.compile_c("cffi_constants",
            self.target_dir("c", "cffi_constants.c"))

    def object_files(self):
        for name in self._cfiles + ["cffi_constants"]:
            yield self.target_dir("obj", name + ".o")

class SalsaCore(Primitive):
    _ptype = "crypto_core"
    _cipher = "salsa20"
    _implementation = "ref"
    _cfiles = ["core"]

#cc -fpic -Wall -shared -Wl,-soname,libbletchleyprimitives.so.1 -o libbletchleyprimitives.so -I . supercop/crypto_stream/chacha12/krovetz/stream.c

def _gather_objfiles(primitives):
    for primitive in primitives:
        for o in primitive.object_files():
            yield o

primitives = [SalsaCore()]

def build_so():
    for primitive in primitives:
        primitive.build()
    makedirs("target/lib")
    run("cc", "-shared", "-Wl,-soname,libbletchleyprimitives.so.1",
        "-o", "target/lib/libbletchleyprimitives.so.1.0.1",
        *list(_gather_objfiles(primitives)))
    run("ldconfig", "-n", "target/lib")
    # Is this really correct?
    if os.path.exists("target/lib/libbletchleyprimitives.so"):
        os.unlink("target/lib/libbletchleyprimitives.so")
    os.symlink("libbletchleyprimitives.so.1.0.1",
        "target/lib/libbletchleyprimitives.so")

def build_c_test():
    makedirs("target/obj")
    run("cc", "-Wall", "-std=c99",
        "-o", "target/obj/call-test.o",
        [['-I', p.target_dir("include")] for p in primitives],
        "-c", "src/main/c/call-test.c")
    makedirs("target/exe")
    run("cc",
        "-o", "target/exe/call-test",
        "target/obj/call-test.o",
        "-L", "target/lib",
        "-lbletchleyprimitives")

def build():
    build_so()
    build_c_test()

if __name__ == "__main__":
    main()
