#!/usr/bin/env python2.7

import os
import os.path
import re

from fabricate import *

def makedirs(d):
    if not os.path.isdir(d):
        os.makedirs(d)

def source_path(*args):
    return os.path.join("fetched/supercop-20130419", *args)

def read_operations():
    with open(source_path("OPERATIONS")) as f:
        for l in f:
            op, macros, prototypes = l.strip().split(None, 2)
            yield (op, dict(
                macros=macros.split(':'),
                prototypes=prototypes.split(':')))

operations = dict(read_operations())

o_header = """#ifndef {o}_H
#define {o}_H

#include "{op}.h"

{op_macros}

{o_macros}
#define {o}_PRIMITIVE "{p}"
#define {o}_IMPLEMENTATION {op}_IMPLEMENTATION

#endif
"""

op_header = """#ifndef {op}_H
#define {op}_H

{apisubst}
#ifdef __cplusplus
extern "C" {{
#endif
{prototypes}
#ifdef __cplusplus
}}
#endif

#define {op}_IMPLEMENTATION "{o}/{p}/{i}"
#ifndef {op}_VERSION
#define {op}_VERSION "-"
#endif

#endif
"""

cffi_op_header = """
{cffi_declarations}
extern char *cffi_{op}_IMPLEMENTATION;
extern char *cffi_{op}_VERSION;

{prototypes}
"""

cffi_constants = """
#include "{op}.h"
#include "cffi_{op}.h"

{cffi_definitions}
char *cffi_{op}_IMPLEMENTATION = {op}_IMPLEMENTATION;
char *cffi_{op}_VERSION = {op}_VERSION;
"""

def write_template(d, namepattern, template, substitutions):
    makedirs(d)
    name = os.path.join(d,
        namepattern.format(**substitutions))
    print "Writing", name
    with open(name, "w") as f:
        f.write(template.format(**substitutions))


class Primitive(object):
    def __init__(self, operation, primitive, implementation):
        self._operation = operation
        self._primitive = primitive
        self._implementation = implementation

    def spath(self):
        return os.path.join(
            self._operation,
            self._primitive,
            self._implementation)

    def target_dir(self, *args):
        return os.path.join("target", self.spath(), *args)

    def source_dir(self, *args):
        return source_path(self.spath(), *args)

    def ops(self, entry):
        return operations[self._operation][entry]

    def api(self):
        with open(self.source_dir("api.h")) as f:
            return f.read()

    def add_macro(self, substitutions, name, macros, template):
        substitutions[name] = "\n".join(
            template.format(**dict(substitutions, macro=macro))
            for macro in macros)

    def write_template(self, d, namepattern, template, substitutions):
        write_template(self.target_dir(d),
            namepattern, template, substitutions)

    def write_templates(self):
        substitutions = dict(
            o=self._operation,
            p=self._primitive,
            i=self._implementation)
        substitutions["op"] = "{o}_{p}".format(**substitutions)
        substitutions["opi"] = "{op}_{i}".format(**substitutions)
        macros = self.ops("macros") + ["_VERSION"]
        self.add_macro(substitutions, "o_macros", macros,
            "#define {o}{macro} {op}{macro}")
        self.add_macro(substitutions, "op_macros", macros,
            "#define {opi}{macro} {op}{macro}")
        macros = [x for x in self.ops("macros") if x.endswith("BYTES")]
        self.add_macro(substitutions, "cffi_declarations", macros,
            "extern int cffi_{op}{macro};")
        self.add_macro(substitutions, "cffi_definitions", macros,
            "int cffi_{op}{macro} = {op}{macro};")
        substitutions["apisubst"] = re.sub(
            r"\sCRYPTO_",
            " {op}_".format(**substitutions),
            self.api().strip())
        substitutions["prototypes"] = "\n".join(
            "extern int {op}{prototype};".format(
                **dict(substitutions, prototype=prototype))
            for prototype in self.ops("prototypes"))
        self.write_template("include", "{o}.h",
            o_header, substitutions)
        self.write_template("include", "{op}.h",
            op_header, substitutions)
        self.write_template("include", "cffi_{op}.h",
            cffi_op_header, substitutions)
        self.write_template("c", "cffi_constants.c",
            cffi_constants, substitutions)

    def compile_c(self, name, source, includes):
        run("cc", "-fpic", "-Wall",
            [['-I', i] for i in includes],
            "-o", self.target_dir("obj", name + ".o"),
            "-c", source)

    def unsorted_cfiles(self):
        for fname in os.listdir(self.source_dir()):
            m = re.match(r"(.+)\.c", fname)
            if m is not None:
                yield m.group(1)

    def cfiles(self):
        return sorted(list(self.unsorted_cfiles()))

    def build(self, includes):
        includes.append(self.target_dir("include"))
        self.write_templates()
        obj = self.target_dir("obj")
        makedirs(obj)
        for name in self.cfiles():
            self.compile_c(name, self.source_dir(name + ".c"), includes)
        self.compile_c("cffi_constants",
            self.target_dir("c", "cffi_constants.c"), includes)

    def object_files(self):
        for name in self.cfiles() + ["cffi_constants"]:
            yield self.target_dir("obj", name + ".o")

def _gather_objfiles(primitives):
    for primitive in primitives:
        for o in primitive.object_files():
            yield o

primitives = [
    Primitive("crypto_core", "salsa20", "ref"),
    Primitive("crypto_verify", "32", "ref"),
    Primitive("crypto_hashblocks", "sha512", "ref"),
    Primitive("crypto_hash", "sha512", "ref"),
    Primitive("crypto_sign", "ed25519", "ref")
]

int_template="""
#ifndef crypto_{n}_h
#define crypto_{n}_h
#include <stdint.h>

typedef {n}_t crypto_{n};

#endif
"""

def build_so():
    for size in [8,16,32,64]:
        for s in ['', 'u']:
            write_template("target/include", "crypto_{n}.h",
                int_template, dict(n="{}int{}".format(s, size)))
    includes = [source_path("include"), "target/include"]
    for primitive in primitives:
        primitive.build(includes)
    makedirs("target/lib")
    run("cc", "-shared", "-Wl,-soname,libbletchleyprimitives.so.1",
        "-o", "target/lib/libbletchleyprimitives.so.1.0.1",
        *list(_gather_objfiles(primitives)))
    run("ldconfig", "-n", "target/lib")
    # Is this really correct?
    if os.path.exists("target/lib/libbletchleyprimitives.so"):
        os.unlink("target/lib/libbletchleyprimitives.so")
    os.symlink("libbletchleyprimitives.so.1.0.1",
        "target/lib/libbletchleyprimitives.so")
    return includes

def build_c_test(includes):
    makedirs("target/obj")
    run("cc", "-Wall", "-std=c99",
        "-o", "target/obj/call-test.o",
        [['-I', i] for i in includes],
        "-c", "src/main/c/call-test.c")
    makedirs("target/exe")
    run("cc",
        "-o", "target/exe/call-test",
        "target/obj/call-test.o",
        "-L", "target/lib",
        "-lbletchleyprimitives")

def build():
    includes = build_so()
    build_c_test(includes)

if __name__ == "__main__":
    main()
