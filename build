#!/usr/bin/env python2.7

import os
import os.path
import re

from fabricate import *

def makedirs(d):
    if not os.path.isdir(d):
        os.makedirs(d)

def source_path(*args):
    return os.path.join("fetched/supercop-20130419", *args)

def read_operations():
    with open(source_path("OPERATIONS")) as f:
        for l in f:
            op, macros, prototypes = l.strip().split(None, 2)
            yield (op, dict(
                macros=macros.split(':'),
                prototypes=prototypes.split(':')))

operations = dict(read_operations())

def write_template(d, namepattern, template, substitutions):
    makedirs(d)
    name = os.path.join(d,
        namepattern.format(**substitutions))
    print "Writing", name
    
    with open(os.path.join("src/main/templates", template)) as t:
        with open(name, "w") as f:
            f.write(t.read().format(**substitutions))

class CState(object):
    def __init__(self):
        self._includes = []
        self._objfiles = []

    def add_include(self, i):
        self._includes.append(i)

    def compile_c(self, objfile, source, extra_includes = []):
        run("cc", "-fpic", "-Wall", '-std=gnu99',
            [['-I', i] for i in self._includes + extra_includes],
            "-o", objfile,
            "-c", source)
        self._objfiles.append(objfile)

    def objfiles(self):
        return self._objfiles

class Primitive(object):
    def __init__(self, operation, primitive, implementation):
        self._operation = operation
        self._primitive = primitive
        self._implementation = implementation

    def spath(self):
        return os.path.join(
            self._operation,
            self._primitive,
            self._implementation)

    def target_dir(self, *args):
        return os.path.join("target", self.spath(), *args)

    def source_dir(self, *args):
        return source_path(self.spath(), *args)

    def ops(self, entry):
        return operations[self._operation][entry]

    def api(self):
        with open(self.source_dir("api.h")) as f:
            return f.read()

    def add_macro(self, substitutions, name, macros, template):
        substitutions[name] = "\n".join(
            template.format(**dict(substitutions, macro=macro))
            for macro in macros)

    def write_templates(self):
        substitutions = dict(
            o=self._operation,
            p=self._primitive,
            i=self._implementation)
        substitutions["op"] = "{o}_{p}".format(**substitutions)
        substitutions["opi"] = "{op}_{i}".format(**substitutions)
        macros = self.ops("macros") + ["_VERSION"]
        self.add_macro(substitutions, "o_macros", macros,
            "#define {o}{macro} {op}{macro}")
        self.add_macro(substitutions, "op_macros", macros,
            "#define {opi}{macro} {op}{macro}")
        macros = [x for x in self.ops("macros") if x.endswith("BYTES")]
        self.add_macro(substitutions, "cffi_declarations", macros,
            "extern int cffi_{op}{macro};")
        self.add_macro(substitutions, "cffi_definitions", macros,
            "int cffi_{op}{macro} = {op}{macro};")
        substitutions["apisubst"] = re.sub(
            r"\sCRYPTO_",
            " {op}_".format(**substitutions),
            self.api().strip())
        substitutions["prototypes"] = "\n".join(
            "extern int {op}{prototype};".format(
                **dict(substitutions, prototype=prototype))
            for prototype in self.ops("prototypes"))
        write_template("target/include/bletchley/primitives", 
            "{op}.h", "op.h", substitutions)
        write_template("target/lib/cffi_headers/bletchley/primitives", 
            "cffi_{op}.h", "cffi_op.h", substitutions)
        write_template(self.target_dir("include"), "{o}.h",
            "o.h", substitutions)
        write_template(self.target_dir("c"), "cffi_constants.c",
            "cffi_constants.c", substitutions)

    def compile_c(self, cstate, name, source, extra_includes = []):
        cstate.compile_c(self.target_dir("obj", name + ".o"), source,
            [self.target_dir("include")] + extra_includes)

    def unsorted_cfiles(self):
        for fname in os.listdir(self.source_dir()):
            m = re.match(r"(.+)\.c", fname)
            if m is not None:
                yield m.group(1)

    def cfiles(self):
        return sorted(list(self.unsorted_cfiles()))

    def build(self, cstate):
        self.write_templates()
        obj = self.target_dir("obj")
        makedirs(obj)
        for name in self.cfiles():
            self.compile_c(cstate, name, self.source_dir(name + ".c"))
        self.compile_c(cstate, "cffi_constants",
            self.target_dir("c", "cffi_constants.c"),
            ["target/lib/cffi_headers/bletchley/primitives"])

primitives = [
    Primitive("crypto_core", "salsa20", "ref"),
    Primitive("crypto_verify", "32", "ref"),
    Primitive("crypto_hashblocks", "sha512", "ref"),
    Primitive("crypto_hash", "sha512", "ref"),
    Primitive("crypto_sign", "ed25519", "ref")
]

def build_so():
    for size in [8,16,32,64]:
        for s in ['', 'u']:
            write_template("target/build/include", "crypto_{n}.h",
                "crypto_n.h", dict(n="{}int{}".format(s, size)))
    cstate = CState()
    cstate.add_include("src/main/include")
    cstate.add_include(source_path("include"))
    cstate.add_include("target/include/bletchley/primitives")
    cstate.add_include("target/build/include")
    makedirs("target/obj")
    cstate.compile_c("target/obj/randombytes.o",
        "src/main/c/randombytes.c")
    for primitive in primitives:
        primitive.build(cstate)
    makedirs("target/lib")
    run("cc", "-shared", "-Wl,-soname,libbletchleyprimitives.so.1",
        "-o", "target/lib/libbletchleyprimitives.so.1.0.1",
        *cstate.objfiles())
    run("ldconfig", "-n", "target/lib")
    # Is this really correct?
    if os.path.exists("target/lib/libbletchleyprimitives.so"):
        os.unlink("target/lib/libbletchleyprimitives.so")
    os.symlink("libbletchleyprimitives.so.1.0.1",
        "target/lib/libbletchleyprimitives.so")

def build_c_test():
    cstate = CState()
    cstate.add_include("target/include/bletchley/primitives")
    makedirs("target/obj")
    cstate.compile_c("target/obj/call-test.o", "src/test/c/call-test.c")
    makedirs("target/exe")
    run("cc",
        "-o", "target/exe/call-test",
        "target/obj/call-test.o",
        "-L", "target/lib",
        "-lbletchleyprimitives")

def build():
    build_so()
    build_c_test()

if __name__ == "__main__":
    main()
